<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Quete de Kortex</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(circle at 20% 20%, #0e1226, #050711 50%, #01040a 90%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #e5ecff;
        }

        #gameContainer {
            position: relative;
            border: 4px solid #1f2d3a;
            box-shadow: 0 0 45px rgba(0, 0, 0, 0.9), 0 0 30px rgba(9, 196, 230, 0.2);
            background: linear-gradient(135deg, #0d1326 0%, #101a2f 50%, #0b1f28 100%);
            border-radius: 12px;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            filter: saturate(1.05) contrast(1.05);
        }

        #scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(0deg,
                    rgba(255, 255, 255, 0.04),
                    rgba(255, 255, 255, 0.04) 1px,
                    transparent 1px,
                    transparent 3px);
            pointer-events: none;
            mix-blend-mode: soft-light;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 30% 20%, rgba(93, 186, 255, 0.15), transparent 40%),
                radial-gradient(circle at 70% 10%, rgba(255, 204, 0, 0.15), transparent 45%),
                linear-gradient(180deg, #05060f 0%, #0c1022 50%, #151a33 100%);
            box-shadow: inset 0 0 60px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            overflow: hidden;
        }

        #startScreen::after {
            content: "";
            position: absolute;
            inset: -40px;
            background:
                radial-gradient(circle at 10% 0%, rgba(255, 255, 255, 0.07), transparent 30%),
                radial-gradient(circle at 90% 20%, rgba(50, 255, 175, 0.1), transparent 25%);
            mix-blend-mode: screen;
            animation: pan 12s linear infinite;
        }

        #startScreen h1 {
            font-size: 44px;
            color: #ffd700;
            text-shadow: 4px 4px 0 #000, 2px 2px 0 #b8860b, 0 0 25px rgba(255, 215, 0, 0.6);
            letter-spacing: 2px;
            margin-bottom: 12px;
            animation: glow 2.2s ease-in-out infinite;
            text-transform: uppercase;
            position: relative;
        }

        #startScreen h2 {
            font-size: 20px;
            color: #c7e7ff;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 28px;
            opacity: 0.9;
        }

        #startScreen .story {
            max-width: 600px;
            text-align: center;
            color: #d9e7ff;
            font-size: 13px;
            line-height: 1.7;
            margin-bottom: 30px;
            padding: 0 20px;
            background: rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.45);
        }

        #startScreen .teams {
            display: flex;
            gap: 15px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }

        #startScreen .team-icon {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            animation: bounce 1s infinite;
            border: 2px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.35);
            font-weight: bold;
        }

        #startScreen .team-icon:nth-child(1) {
            background: linear-gradient(135deg, #b07ce6, #7f4db4);
            animation-delay: 0s;
        }

        #startScreen .team-icon:nth-child(2) {
            background: linear-gradient(135deg, #ff5c5c, #c0392b);
            animation-delay: 0.1s;
        }

        #startScreen .team-icon:nth-child(3) {
            background: linear-gradient(135deg, #4cb8ff, #226fa8);
            animation-delay: 0.2s;
        }

        #startScreen .team-icon:nth-child(4) {
            background: linear-gradient(135deg, #ffb347, #e16b00);
            animation-delay: 0.3s;
        }

        #startScreen .team-icon:nth-child(5) {
            background: linear-gradient(135deg, #41d57b, #1f8a4d);
            animation-delay: 0.4s;
        }

        #startScreen p {
            font-size: 16px;
            color: #9ee8b1;
            text-shadow: 2px 2px 0 #000;
        }

        #startScreen .cta {
            font-size: 18px;
            color: #00ffc6;
            letter-spacing: 1px;
            animation: pulse 1.1s ease-in-out infinite;
        }

        @keyframes glow {

            0%,
            100% {
                text-shadow: 4px 4px 0 #000, 2px 2px 0 #b8860b, 0 0 20px #ffd700;
            }

            50% {
                text-shadow: 4px 4px 0 #000, 2px 2px 0 #b8860b, 0 0 40px #ffd700;
            }
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-8px);
            }
        }

        @keyframes blink {

            0%,
            50% {
                opacity: 1;
            }

            51%,
            100% {
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                filter: drop-shadow(0 0 0 rgba(0, 255, 198, 0.3));
            }

            50% {
                transform: scale(1.04);
                filter: drop-shadow(0 0 14px rgba(0, 255, 198, 0.6));
            }

            100% {
                transform: scale(1);
                filter: drop-shadow(0 0 0 rgba(0, 255, 198, 0.3));
            }
        }

        @keyframes pan {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-30px);
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="500"></canvas>
        <div id="scanlines"></div>
        <div id="startScreen">
            <h1>>> LA QUETE DE KORTEX <<<</h1>
                    <h2>5 EQUIPES, UN SEUL CHATEAU</h2>
                    <div class="story">
                        5 equipes prisonnieres d'outils differents partent rejoindre le chateau KORTEX.<br>
                        Ateliers metier, parametrage, formation... elles devront se synchroniser et terrasser leurs
                        anciens outils.<br>
                        Objectif final : celebrer l'arrivee dans ZENDESK unifie !
                    </div>
                    <div class="teams">
                        <div class="team-icon">R</div>
                        <div class="team-icon">CRC</div>
                        <div class="team-icon">BO</div>
                        <div class="team-icon">F</div>
                        <div class="team-icon">V</div>
                    </div>
                    <p class="cta">>> Cliquez pour lancer l'aventure <<<</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');

        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const GROUND_Y = HEIGHT - 80;

        // √âtat global
        let gameState = 'start';
        let frameCount = 0;
        let currentPhase = 'workshop'; // workshop, quest, boss, castle, final
        let phaseTimer = 0;
        let flags = [];
        let particles = [];
        let damageNumbers = [];
        let shake = 0;
        let hitStop = 0;
        let flash = 0;

        // √âquipes
        const allTeams = [
            { name: 'Reclamations', shortName: 'Reclam.', color: '#9b59b6', darkColor: '#8e44ad' },
            { name: 'CRC', shortName: 'CRC', color: '#e52521', darkColor: '#c0392b' },
            { name: 'BO', shortName: 'BO', color: '#3498db', darkColor: '#2980b9' },
            { name: 'Flex/Mobibus', shortName: 'Flex', color: '#f39c12', darkColor: '#d68910' },
            { name: 'Reclam. Velo', shortName: 'R.Velo', color: '#27ae60', darkColor: '#229954' }
        ];

        // S√©quences de qu√™te
        const questSequences = [
            {
                teams: [allTeams[0]], // R√©clamations
                boss: { name: 'DYNAMOX', subtitle: 'Dynamics', color: '#00bcf2', icon: 'ü§ñ' },
                flagColors: ['#9b59b6']
            },
            {
                teams: [allTeams[1], allTeams[2]], // CRC + BO
                boss: { name: 'KEOLISHELP', subtitle: 'Zendesk v1', color: '#78a300', icon: 'üëæ' },
                flagColors: ['#e52521', '#3498db']
            },
            {
                teams: [allTeams[3], allTeams[4]], // Flex + R√©clam V√©lo
                parallel: true,
                bosses: [
                    { name: 'OUTLORD', subtitle: 'Outlook', color: '#0078d4', icon: 'üìß' },
                    { name: 'DYNAMOX', subtitle: 'Dynamics', color: '#00bcf2', icon: 'ü§ñ' }
                ],
                flagColors: ['#f39c12', '#27ae60']
            }
        ];

        let currentQuestIndex = 0;
        let questState = 'scroll'; // scroll, checkpoint, boss_intro, fight, victory, castle
        let scrollX = 0;
        let heroX = 100;
        let checkpointsPassed = 0;
        let showCheckpointMessage = null;
        let checkpointMessageTimer = 0;
        let bossHP = 100;
        let bossMaxHP = 100;
        let attackTimer = 0;
        let heroAttacking = false;
        let bossHit = false;
        let bossHitTimer = 0;

        // Checkpoints / Totems
        const checkpoints = [
            { x: 600, label: 'Parametrage', icon: '[P]', passed: false, glowTimer: 0 },
            { x: 1200, label: 'Formation', icon: '[F]', passed: false, glowTimer: 0 }
        ];

        const BOSS_POSITION = 1800;
        const QUEST_END = 2200;

        // Workshop state
        let workshopPhase = 0;
        let workshopTimer = 0;
        let typingText = '';
        let typingIndex = 0;
        let typingTimer = 0;

        // Audio
        let audioCtx;

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!audioCtx) return;

            const sounds = {
                'step': { freq: 150, duration: 0.05, type: 'square', gain: 0.05 },
                'checkpoint': { freqs: [523, 659, 784, 1047], duration: 0.18, type: 'square', gain: 0.18 },
                'totem_glow': { freqs: [880, 1108, 1320], duration: 0.12, type: 'sine', gain: 0.12 },
                'boss_intro': { freqs: [200, 180, 160, 140], duration: 0.2, type: 'sawtooth', gain: 0.15 },
                'attack': { freq: 300, freqEnd: 50, duration: 0.1, type: 'sawtooth', gain: 0.15 },
                'hit': { freq: 150, freqEnd: 50, duration: 0.1, type: 'square', gain: 0.2 },
                'boss_death': { freqs: [200, 150, 100, 80, 60, 40], duration: 0.1, type: 'sawtooth', gain: 0.25 },
                'victory': { freqs: [523, 659, 784, 1047], duration: 0.3, type: 'square', gain: 0.15 },
                'flag': { freqs: [698, 880, 1047], duration: 0.2, type: 'triangle', gain: 0.12 },
                'workshop': { freqs: [440, 550, 660], duration: 0.2, type: 'sine', gain: 0.1 },
                'typing': { freq: 800, duration: 0.02, type: 'square', gain: 0.03 },
                'final': { freqs: [523, 523, 698, 784, 698, 784, 1047, 1175, 1319], duration: 0.15, type: 'square', gain: 0.12 }
            };

            const s = sounds[type];
            if (!s) return;

            if (s.freqs) {
                s.freqs.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.frequency.value = freq;
                    osc.type = s.type;
                    gain.gain.setValueAtTime(s.gain, audioCtx.currentTime + i * (s.duration * 0.5));
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * (s.duration * 0.5) + s.duration);
                    osc.start(audioCtx.currentTime + i * (s.duration * 0.5));
                    osc.stop(audioCtx.currentTime + i * (s.duration * 0.5) + s.duration);
                });
            } else {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.setValueAtTime(s.freq, audioCtx.currentTime);
                if (s.freqEnd) osc.frequency.exponentialRampToValueAtTime(s.freqEnd, audioCtx.currentTime + s.duration);
                osc.type = s.type;
                gain.gain.setValueAtTime(s.gain, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + s.duration);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + s.duration);
            }
        }

        // Particules
        function addParticles(x, y, color, count = 10, type = 'normal') {
            const presets = {
                normal: { speed: 8, lift: 3, gravity: 0.35, friction: 0.92, life: 40, lifeVar: 20, minSize: 3, sizeVar: 3, colors: [color || '#ffd700'] },
                spark: { speed: 10, lift: 4, gravity: 0.1, friction: 0.95, life: 25, lifeVar: 15, minSize: 2, sizeVar: 2, colors: ['#fff', color || '#ffd700'] },
                explosion: { speed: 12, lift: 5, gravity: 0.2, friction: 0.9, life: 50, lifeVar: 30, minSize: 3, sizeVar: 4, colors: [color || '#ff7800', '#ffd700'] },
                confetti: { speed: 9, lift: 2, gravity: 0.25, friction: 0.93, life: 70, lifeVar: 30, minSize: 3, sizeVar: 3, colors: ['#ff6b6b', '#ffd93d', '#6bcff6', '#9bffb3', '#d484ff'] }
            };
            const preset = presets[type] || presets.normal;

            for (let i = 0; i < count; i++) {
                const chosen = preset.colors[Math.floor(Math.random() * preset.colors.length)];
                const life = preset.life + Math.random() * preset.lifeVar;
                particles.push({
                    x,
                    y,
                    vx: (Math.random() - 0.5) * preset.speed,
                    vy: (Math.random() - 0.5) * preset.speed - preset.lift,
                    color: chosen,
                    life,
                    maxLife: life,
                    size: preset.minSize + Math.random() * preset.sizeVar,
                    gravity: preset.gravity,
                    friction: preset.friction,
                    type
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity ?? 0.3;
                p.vx *= p.friction ?? 0.94;
                p.life--;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                const alpha = Math.max(0, p.life / (p.maxLife || 60));
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                if (p.type === 'spark') {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.type === 'confetti') {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate((p.life % 20) * 0.2);
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
                    ctx.restore();
                } else {
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                }
            });
            ctx.globalAlpha = 1;
        }

        // Damage Numbers
        function addDamageNumber(x, y, damage) {
            damageNumbers.push({
                x, y,
                damage,
                life: 60,
                vy: -3
            });
        }

        function updateDamageNumbers() {
            damageNumbers = damageNumbers.filter(d => {
                d.y += d.vy;
                d.vy += 0.1;
                d.life--;
                return d.life > 0;
            });
        }

        function drawDamageNumbers() {
            damageNumbers.forEach(d => {
                const scale = 1 + Math.sin((60 - d.life) * 0.2) * 0.5;
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.scale(scale, scale);

                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeText(d.damage, 0, 0);
                ctx.fillText(d.damage, 0, 0);

                ctx.restore();
            });
        }

        // Dessiner un h√©ros
        function drawHero(x, y, team, frame, attacking = false, scale = 1) {
            const px = 4 * scale;
            ctx.save();
            ctx.translate(x, y);

            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.beginPath();
            ctx.ellipse(0, px * 3.5, px * 2.6, px * 0.9, 0, 0, Math.PI * 2);
            ctx.fill();

            if (attacking) ctx.translate(10 * scale, 0);

            // Corps
            ctx.fillStyle = team.color;
            ctx.fillRect(-px * 2, -px * 2, px * 4, px * 5);

            // T√™te
            ctx.fillStyle = '#ffccaa';
            ctx.fillRect(-px * 1.5, -px * 5, px * 3, px * 3);

            // Casque
            ctx.fillStyle = team.darkColor;
            ctx.fillRect(-px * 2, -px * 6, px * 4, px * 2);

            // Yeux
            ctx.fillStyle = '#000';
            ctx.fillRect(-px * 0.5, -px * 4, px * 0.8, px);
            ctx.fillRect(px * 0.5, -px * 4, px * 0.8, px);

            // √âp√©e
            ctx.fillStyle = '#c0c0c0';
            if (attacking) {
                ctx.fillRect(px * 2, -px * 2, px * 6, px * 1.5);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(px * 1.5, -px * 3, px * 1, px * 3);
            } else {
                ctx.fillRect(px * 2.5, -px * 6, px * 1.5, px * 5);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(px * 1.5, -px * 2, px * 3, px * 1);
            }

            // Jambes anim√©es
            ctx.fillStyle = '#1a1a2e';
            const legOffset = Math.sin(frame * 0.3) * 2 * scale;
            ctx.fillRect(-px * 1.5, px * 3, px * 1.5, px * 2 + legOffset);
            ctx.fillRect(px * 0.5, px * 3, px * 1.5, px * 2 - legOffset);

            ctx.restore();
        }

        // Dessiner un totem/panneau
        function drawTotem(x, y, checkpoint, passed) {
            ctx.save();
            ctx.translate(x, y);
            
            const isGlowing = checkpoint.glowTimer > 0;
            const glowIntensity = checkpoint.glowTimer / 60;

            // Lueur autour du totem quand activ√©
            if (isGlowing || passed) {
                const glowColor = passed ? '#4ade80' : '#ffd700';
                const intensity = passed ? 0.4 : glowIntensity * 0.6;
                
                // Halo ext√©rieur
                const gradient = ctx.createRadialGradient(0, -70, 0, 0, -70, 120);
                gradient.addColorStop(0, `rgba(${passed ? '74, 222, 128' : '255, 215, 0'}, ${intensity})`);
                gradient.addColorStop(0.5, `rgba(${passed ? '74, 222, 128' : '255, 215, 0'}, ${intensity * 0.3})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, -70, 120, 0, Math.PI * 2);
                ctx.fill();
                
                // Rayons de lumi√®re
                if (isGlowing) {
                    ctx.strokeStyle = `rgba(255, 215, 0, ${glowIntensity * 0.5})`;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2 + frameCount * 0.05;
                        const innerRadius = 60;
                        const outerRadius = 90 + Math.sin(frameCount * 0.2 + i) * 10;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * innerRadius, -70 + Math.sin(angle) * innerRadius * 0.5);
                        ctx.lineTo(Math.cos(angle) * outerRadius, -70 + Math.sin(angle) * outerRadius * 0.5);
                        ctx.stroke();
                    }
                }
            }

            // Poteau
            ctx.fillStyle = isGlowing ? '#6b5040' : '#4a3728';
            ctx.fillRect(-8, -80, 16, 100);
            
            // Effet lumineux sur le poteau
            if (isGlowing) {
                ctx.fillStyle = `rgba(255, 215, 0, ${glowIntensity * 0.3})`;
                ctx.fillRect(-8, -80, 16, 100);
            }

            // Panneau avec effet de brillance
            const panelColor = passed ? '#2d5a2d' : (isGlowing ? '#7a5a3d' : '#5a3d2d');
            ctx.fillStyle = panelColor;
            ctx.fillRect(-50, -120, 100, 50);
            
            // Effet de brillance sur le panneau
            if (isGlowing) {
                const pulseAlpha = 0.3 + Math.sin(frameCount * 0.3) * 0.2;
                ctx.fillStyle = `rgba(255, 215, 0, ${pulseAlpha * glowIntensity})`;
                ctx.fillRect(-50, -120, 100, 50);
            }

            // Bordure avec effet lumineux
            ctx.strokeStyle = passed ? '#4ade80' : (isGlowing ? '#ffdd44' : '#ffd700');
            ctx.lineWidth = isGlowing ? 4 + Math.sin(frameCount * 0.4) * 2 : 3;
            ctx.strokeRect(-50, -120, 100, 50);
            
            // Deuxi√®me bordure externe si glow
            if (isGlowing) {
                ctx.strokeStyle = `rgba(255, 215, 0, ${glowIntensity * 0.5})`;
                ctx.lineWidth = 2;
                ctx.strokeRect(-54, -124, 108, 58);
            }

            // Ic√¥ne avec effet de brillance
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillStyle = isGlowing ? '#fff' : '#ddd';
            if (isGlowing) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 15;
            }
            ctx.fillText(checkpoint.icon, 0, -85);
            ctx.shadowBlur = 0;

            // Label
            ctx.fillStyle = isGlowing ? '#fff' : '#fff';
            ctx.font = 'bold 11px Courier New';
            if (isGlowing) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 10;
            }
            ctx.fillText(checkpoint.label, 0, -75);
            ctx.shadowBlur = 0;

            // Check si pass√©
            if (passed) {
                ctx.fillStyle = '#4ade80';
                ctx.font = 'bold 20px Arial';
                ctx.shadowColor = '#4ade80';
                ctx.shadowBlur = 10;
                ctx.fillText('‚úì', 35, -90);
                ctx.shadowBlur = 0;
            }

            // D√©corations totem avec glow
            ctx.fillStyle = isGlowing ? '#ffee88' : '#ffd700';
            if (isGlowing) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 15;
            }
            ctx.beginPath();
            ctx.moveTo(-8, -80);
            ctx.lineTo(0, -90);
            ctx.lineTo(8, -80);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Particules lumineuses autour du totem quand il brille
            if (isGlowing) {
                for (let i = 0; i < 3; i++) {
                    const sparkX = (Math.random() - 0.5) * 80;
                    const sparkY = -70 + (Math.random() - 0.5) * 60;
                    const sparkSize = 2 + Math.random() * 2;
                    ctx.fillStyle = `rgba(255, 255, 200, ${0.5 + Math.random() * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.textAlign = 'left';
            ctx.restore();
        }

        // Dessiner un boss
        function drawBoss(x, y, boss, frame, hit = false) {
            const px = 5;
            ctx.save();
            ctx.translate(x, y);

            const floatY = Math.sin(frame * 0.1) * 8;
            ctx.translate(0, floatY);

            ctx.fillStyle = hit ? '#fff' : boss.color;

            if (boss.icon === 'ü§ñ') {
                // Robot Dynamox
                ctx.fillRect(-px * 4, -px * 3, px * 8, px * 8);
                ctx.fillRect(-px * 3, -px * 7, px * 6, px * 4);
                ctx.fillRect(-px * 2, -px * 9, px, px * 2);
                ctx.fillRect(px * 1, -px * 9, px, px * 2);
                ctx.fillStyle = hit ? '#fff' : '#ff0000';
                ctx.fillRect(-px * 2, -px * 6, px * 1.5, px * 1.5);
                ctx.fillRect(px * 0.5, -px * 6, px * 1.5, px * 1.5);
                ctx.fillStyle = hit ? '#fff' : boss.color;
                ctx.fillRect(-px * 6, -px * 2, px * 2, px * 5);
                ctx.fillRect(px * 4, -px * 2, px * 2, px * 5);
                ctx.fillRect(-px * 3, px * 5, px * 2, px * 3);
                ctx.fillRect(px * 1, px * 5, px * 2, px * 3);
            } else if (boss.icon === 'üëæ') {
                // Fant√¥me Legacy
                ctx.beginPath();
                ctx.arc(0, -px * 2, px * 5, Math.PI, 0);
                ctx.fillRect(-px * 5, -px * 2, px * 10, px * 6);
                ctx.fill();
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.arc(-px * 4 + i * px * 2, px * 4, px, 0, Math.PI);
                    ctx.fill();
                }
                ctx.fillStyle = hit ? '#fff' : '#000';
                ctx.fillRect(-px * 3, -px * 3, px * 2, px * 2);
                ctx.fillRect(px * 1, -px * 3, px * 2, px * 2);
            } else if (boss.icon === 'üìß') {
                // Outlord
                ctx.fillRect(-px * 6, -px * 3, px * 12, px * 8);
                ctx.fillStyle = hit ? '#fff' : '#005a9e';
                ctx.beginPath();
                ctx.moveTo(-px * 6, -px * 3);
                ctx.lineTo(0, px * 2);
                ctx.lineTo(px * 6, -px * 3);
                ctx.fill();
                ctx.fillStyle = hit ? '#fff' : '#ff0000';
                ctx.fillRect(-px * 3, -px, px * 2, px * 2);
                ctx.fillRect(px * 1, -px, px * 2, px * 2);
                ctx.fillStyle = hit ? '#fff' : boss.color;
                ctx.beginPath();
                ctx.moveTo(-px * 6, -px * 2);
                ctx.lineTo(-px * 9, -px * 5);
                ctx.lineTo(-px * 6, px * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(px * 6, -px * 2);
                ctx.lineTo(px * 9, -px * 5);
                ctx.lineTo(px * 6, px * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Dessiner le ch√¢teau
        function drawCastle(x, y, scale = 1, currentFlags = []) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            // Lueur
            if (currentFlags.length > 0) {
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 150);
                gradient.addColorStop(0, `rgba(255, 215, 0, ${0.1 + currentFlags.length * 0.05})`);
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, 150, 0, Math.PI * 2);
                ctx.fill();
            }

            // Base
            ctx.fillStyle = '#d4a574';
            ctx.fillRect(-70, -20, 140, 100);

            // Tours
            ctx.fillStyle = '#c49464';
            ctx.fillRect(-90, -60, 40, 140);
            ctx.fillRect(50, -60, 40, 140);
            ctx.fillRect(-30, -80, 60, 160);

            // Toits Zendesk
            ctx.fillStyle = '#03363d';
            ctx.beginPath();
            ctx.moveTo(-95, -60);
            ctx.lineTo(-70, -100);
            ctx.lineTo(-45, -60);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(45, -60);
            ctx.lineTo(70, -100);
            ctx.lineTo(95, -60);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-35, -80);
            ctx.lineTo(0, -130);
            ctx.lineTo(35, -80);
            ctx.fill();

            // Fen√™tres
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-80, -40, 15, 20);
            ctx.fillRect(65, -40, 15, 20);
            ctx.fillRect(-15, -60, 12, 15);
            ctx.fillRect(3, -60, 12, 15);

            // Porte
            ctx.fillStyle = '#4a3728';
            ctx.beginPath();
            ctx.arc(0, 50, 25, Math.PI, 0);
            ctx.fillRect(-25, 50, 50, 30);
            ctx.fill();

            // KORTEX
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('KORTEX', 0, 35);

            // Z Zendesk
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 20px Arial';
            ctx.fillText('Z', 0, -105);

            // Drapeaux
            const flagPos = [
                { x: -70, y: -100 },
                { x: 70, y: -100 },
                { x: 0, y: -130 },
                { x: -90, y: -60 },
                { x: 90, y: -60 }
            ];

            currentFlags.forEach((color, i) => {
                if (i < flagPos.length) {
                    const fp = flagPos[i];
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(fp.x - 2, fp.y - 35, 4, 35);
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(fp.x + 2, fp.y - 35);
                    ctx.lineTo(fp.x + 25 + Math.sin(frameCount * 0.1) * 3, fp.y - 25);
                    ctx.lineTo(fp.x + 2, fp.y - 15);
                    ctx.fill();
                }
            });

            ctx.textAlign = 'left';
            ctx.restore();
        }

        // Dessiner la barre de vie
        function drawBossHP(boss, hp, maxHP) {
            const barWidth = 250;
            const barHeight = 18;
            const x = WIDTH / 2 - barWidth / 2;
            const y = 50;

            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(x - 15, y - 28, barWidth + 30, barHeight + 45);

            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 15, y - 28, barWidth + 30, barHeight + 45);

            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`${boss.icon} ${boss.name}`, WIDTH / 2, y - 10);
            ctx.fillStyle = '#888';
            ctx.font = '10px Courier New';
            ctx.fillText(`[ ${boss.subtitle} ]`, WIDTH / 2, y + 3);
            ctx.textAlign = 'left';

            ctx.fillStyle = '#333';
            ctx.fillRect(x, y + 12, barWidth, barHeight);

            const hpWidth = Math.max(0, (hp / maxHP)) * barWidth;
            const gradient = ctx.createLinearGradient(x, y, x + hpWidth, y);
            gradient.addColorStop(0, '#ff0000');
            gradient.addColorStop(0.5, '#ff4444');
            gradient.addColorStop(1, '#ff0000');
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y + 12, hpWidth, barHeight);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y + 12, barWidth, barHeight);
        }

        // Fond scroll side-scroller
        function drawScrollBackground(offsetX) {
            const gradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            gradient.addColorStop(0, '#0f1530');
            gradient.addColorStop(0.45, '#1a1f3d');
            gradient.addColorStop(1, '#0f2518');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = 'rgba(0, 255, 198, 0.05)';
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(-100 + i * 180, 40 + Math.sin(frameCount * 0.01 + i) * 15, WIDTH, 12);
            }

            ctx.fillStyle = '#dce7ff';
            for (let i = 0; i < 60; i++) {
                const sx = ((i * 93) - offsetX * 0.05) % WIDTH;
                const sy = (i * 41) % (HEIGHT * 0.35);
                ctx.fillRect(sx < 0 ? sx + WIDTH : sx, sy, 2, 2);
            }

            ctx.fillStyle = '#162336';
            for (let i = 0; i < 8; i++) {
                const mx = ((i * 180) - offsetX * 0.1) % (WIDTH + 300) - 150;
                const peak = GROUND_Y - 140 - (i % 3) * 35;
                ctx.beginPath();
                ctx.moveTo(mx, GROUND_Y);
                ctx.lineTo(mx + 100, peak);
                ctx.lineTo(mx + 220, GROUND_Y);
                ctx.fill();
            }

            ctx.fillStyle = '#1f3b32';
            for (let i = 0; i < 6; i++) {
                const mx = ((i * 220) - offsetX * 0.2) % (WIDTH + 300) - 150;
                const peak = GROUND_Y - 110 - (i % 2) * 30;
                ctx.beginPath();
                ctx.moveTo(mx, GROUND_Y);
                ctx.lineTo(mx + 80, peak);
                ctx.lineTo(mx + 170, GROUND_Y);
                ctx.fill();
            }

            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            for (let i = 0; i < 6; i++) {
                const cx = ((i * 200) - offsetX * 0.25) % (WIDTH + 400) - 200;
                const cy = 70 + (i % 2) * 20 + Math.sin(frameCount * 0.02 + i) * 6;
                ctx.beginPath();
                ctx.ellipse(cx, cy, 70, 25, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            for (let i = 0; i < 14; i++) {
                const tx = ((i * 150) - offsetX * 0.4) % (WIDTH + 200) - 100;
                ctx.fillStyle = '#3d2817';
                ctx.fillRect(tx + 12, GROUND_Y - 50, 16, 50);
                ctx.fillStyle = '#1a4a1a';
                ctx.beginPath();
                ctx.moveTo(tx, GROUND_Y - 40);
                ctx.lineTo(tx + 20, GROUND_Y - 100);
                ctx.lineTo(tx + 40, GROUND_Y - 40);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(tx + 5, GROUND_Y - 70);
                ctx.lineTo(tx + 20, GROUND_Y - 120);
                ctx.lineTo(tx + 35, GROUND_Y - 70);
                ctx.fill();
            }

            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, GROUND_Y, WIDTH, HEIGHT - GROUND_Y);

            ctx.fillStyle = '#5c4033';
            ctx.fillRect(0, GROUND_Y + 10, WIDTH, 50);
            ctx.fillStyle = 'rgba(255, 222, 173, 0.08)';
            ctx.fillRect(0, GROUND_Y + 10, WIDTH, 8);

            ctx.fillStyle = '#6b5344';
            for (let i = 0; i < 32; i++) {
                const px = ((i * 80) - offsetX * 0.8) % (WIDTH + 100) - 50;
                ctx.fillRect(px, GROUND_Y + 20 + (i % 3) * 12, 12 + (i % 4) * 3, 6);
            }
        }

        // Fond atelier
        function drawWorkshopBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            gradient.addColorStop(0, '#2a1a3a');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = '#3a2a4a';
            ctx.fillRect(50, 50, WIDTH - 100, HEIGHT - 150);

            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = '#4a6080';
                ctx.fillRect(120 + i * 280, 80, 80, 100);
                ctx.strokeStyle = '#2a2a3a';
                ctx.lineWidth = 4;
                ctx.strokeRect(120 + i * 280, 80, 80, 100);
                ctx.beginPath();
                ctx.moveTo(160 + i * 280, 80);
                ctx.lineTo(160 + i * 280, 180);
                ctx.stroke();
            }

            ctx.fillStyle = '#4a3a2a';
            ctx.fillRect(50, HEIGHT - 100, WIDTH - 100, 50);
            ctx.strokeStyle = '#6b5344';
            ctx.lineWidth = 2;
            ctx.strokeRect(50, HEIGHT - 100, WIDTH - 100, 50);

            ctx.fillStyle = '#8e5a2a';
            ctx.fillRect(200, HEIGHT / 2 + 40, WIDTH - 400, 30);
            ctx.strokeStyle = '#c49464';
            ctx.lineWidth = 4;
            ctx.strokeRect(200, HEIGHT / 2 + 40, WIDTH - 400, 30);

            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('ATELIERS METIER', WIDTH / 2, 110);
            ctx.fillStyle = '#fff';
            ctx.font = '12px Courier New';
            ctx.fillText('Definition des besoins', WIDTH / 2, 135);
            ctx.fillText('Expression des processus', WIDTH / 2, 155);
            ctx.fillText('Convergence des equipes', WIDTH / 2, 175);
            ctx.textAlign = 'left';
        }

        // Fond combat
        function drawBattleBackground() {
            const gradient = ctx.createRadialGradient(WIDTH / 2, HEIGHT / 2, 0, WIDTH / 2, HEIGHT / 2, 400);
            gradient.addColorStop(0, '#2d1b4e');
            gradient.addColorStop(1, '#0a0a15');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.ellipse(WIDTH / 2, GROUND_Y + 20, 350, 50, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#4a3728';
            ctx.lineWidth = 4;
            ctx.stroke();

            for (let i = 0; i < 4; i++) {
                const tx = 100 + i * 250;
                ctx.fillStyle = '#4a3728';
                ctx.fillRect(tx - 5, 100, 10, 80);
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(tx, 90 + Math.sin(frameCount * 0.2 + i) * 5, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(tx, 85 + Math.sin(frameCount * 0.2 + i) * 5, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#ffbf69';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('>> DEPLOIEMENT <<', WIDTH / 2, 30);
            ctx.textAlign = 'left';
        }

        // Fond chateau
        function drawCastleBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            gradient.addColorStop(0, '#1a3a5f');
            gradient.addColorStop(0.5, '#2d5a7b');
            gradient.addColorStop(1, '#3d7a4a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = '#ffd700';
            for (let i = 0; i < 30; i++) {
                const sx = (i * 73) % WIDTH;
                const sy = (i * 41) % (HEIGHT * 0.4);
                const size = 2 + Math.sin(frameCount * 0.1 + i) * 1;
                ctx.fillRect(sx, sy, size, size);
            }

            ctx.fillStyle = '#3d6b3d';
            ctx.fillRect(0, GROUND_Y, WIDTH, HEIGHT - GROUND_Y);

            ctx.fillStyle = '#c49464';
            ctx.beginPath();
            ctx.moveTo(0, HEIGHT);
            ctx.lineTo(WIDTH / 2 - 80, GROUND_Y);
            ctx.lineTo(WIDTH / 2 + 80, GROUND_Y);
            ctx.lineTo(WIDTH, HEIGHT);
            ctx.fill();
        }

        function drawCheckpointMessage(label, icon) {
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(WIDTH / 2 - 150, HEIGHT / 2 - 50, 300, 70);

            ctx.strokeStyle = '#4ade80';
            ctx.lineWidth = 3;
            ctx.strokeRect(WIDTH / 2 - 150, HEIGHT / 2 - 50, 300, 70);

            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 22px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`${icon} ${label}`, WIDTH / 2, HEIGHT / 2 - 10);

            ctx.fillStyle = '#fff';
            ctx.font = '14px Courier New';
            ctx.fillText('> Etape validee ! <', WIDTH / 2, HEIGHT / 2 + 15);
            ctx.textAlign = 'left';
        }

        function drawMessage(text, subtext = '', color = '#ffd700') {
            const height = subtext ? 80 : 60;
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(WIDTH / 2 - 200, HEIGHT / 2 - 50, 400, height);

            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.strokeRect(WIDTH / 2 - 200, HEIGHT / 2 - 50, 400, height);

            ctx.fillStyle = color;
            ctx.font = 'bold 22px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(text, WIDTH / 2, HEIGHT / 2 - 15);

            if (subtext) {
                ctx.fillStyle = '#fff';
                ctx.font = '14px Courier New';
                ctx.fillText(subtext, WIDTH / 2, HEIGHT / 2 + 15);
            }
            ctx.textAlign = 'left';
        }

        function drawCastleHUD() {
            if (flags.length === 0) return;

            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(WIDTH - 170, 10, 160, 30 + flags.length * 18);

            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(WIDTH - 170, 10, 160, 30 + flags.length * 18);

            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 11px Courier New';
            ctx.fillText('Dans KORTEX:', WIDTH - 160, 28);

            const names = ['Reclamations', 'CRC', 'BO', 'Flex/Mobibus', 'Reclam. Velo'];
            flags.forEach((color, i) => {
                ctx.fillStyle = color;
                ctx.fillText('>', WIDTH - 160, 48 + i * 18);
            });
        }

        function drawProgressBar() {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(10, HEIGHT - 35, 200, 25);

            ctx.fillStyle = '#ffd700';
            ctx.font = '12px Courier New';
            ctx.fillText('Equipes liberees: /5', 20, HEIGHT - 17);
        }

        function drawFinalScreen() {
            const gradient = ctx.createLinearGradient(0, 0, 0, HEIGHT);
            gradient.addColorStop(0, '#0a1628');
            gradient.addColorStop(1, '#1a3a28');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Titre
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 28px Courier New';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 15;
            ctx.fillText('üèÜ LEADERBOARD üèÜ', WIDTH / 2, 35);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#4ade80';
            ctx.font = '14px Courier New';
            ctx.fillText('Les h√©ros de la migration KORTEX', WIDTH / 2, 55);

            // Liste des participants
            const participants = [
                'Muriel', 'M√©laine', 'C√©line', 'Marine', 'Mathilde', 'Sandra',
                'Chlo√©', 'Virgile', 'Thierry', 'Adeline', 'Aline', 'Benjamin',
                'Micka√´l', 'Thomas', 'Lo√Øc', 'Audrey', 'Mimount', 'Morgane',
                'Fr√©d√©ric', 'Abdelhamid', 'S√©bastien', 'Stanislas', 'J√©r√¥me', 'Julien(s)'
            ];

            // Couleurs d'avatar
            const avatarColors = [
                '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f39c12', '#1abc9c',
                '#e91e63', '#00bcd4', '#ff5722', '#8bc34a', '#673ab7', '#ffc107'
            ];

            // Disposition en 4 colonnes
            const cols = 4;
            const rows = Math.ceil(participants.length / cols);
            const colWidth = 210;
            const rowHeight = 52;
            const startX = (WIDTH - cols * colWidth) / 2 + 20;
            const startY = 75;

            participants.forEach((name, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const x = startX + col * colWidth;
                const y = startY + row * rowHeight;

                // Fond de la ligne
                ctx.fillStyle = row % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.2)';
                ctx.fillRect(x - 15, y - 12, colWidth - 10, 44);

                // Avatar (cercle avec initiale)
                const avatarColor = avatarColors[index % avatarColors.length];
                ctx.fillStyle = avatarColor;
                ctx.beginPath();
                ctx.arc(x + 5, y + 10, 16, 0, Math.PI * 2);
                ctx.fill();

                // Bordure avatar
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Initiale
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(name.charAt(0).toUpperCase(), x + 5, y + 15);

                // Nom
                ctx.fillStyle = '#fff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(name, x + 28, y + 8);

                // 5 √©toiles
                ctx.fillStyle = '#ffd700';
                ctx.font = '12px Arial';
                const stars = '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ';
                ctx.fillText(stars, x + 28, y + 24);
            });

            // Petit ch√¢teau en bas
            drawCastle(WIDTH / 2, HEIGHT - 50, 0.4, flags);

            // Message final
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('ZENDESK UNIFI√â - MISSION ACCOMPLIE !', WIDTH / 2, HEIGHT - 10);

            ctx.textAlign = 'left';
        }

        // === MISE A JOUR ===
        function update() {
            if (gameState !== 'playing') return;

            if (hitStop > 0) {
                hitStop--;
                return;
            }

            frameCount++;
            updateParticles();
            updateDamageNumbers();

            switch (currentPhase) {
                case 'workshop':
                    updateWorkshop();
                    break;
                case 'quest':
                    updateQuest();
                    break;
                case 'final':
                    // Rien √† faire
                    break;
            }
        }

        function updateWorkshop() {
            workshopTimer++;

            // Phase 0: Entr√©e des personnages
            if (workshopPhase === 0) {
                if (workshopTimer > 120) {
                    workshopPhase = 1;
                    workshopTimer = 0;
                    playSound('workshop');
                }
            }
            // Phase 1: Discussion (texte qui s'affiche)
            else if (workshopPhase === 1) {
                const fullText = "Definissons ensemble nos besoins communs...";
                typingTimer++;
                if (typingTimer > 3 && typingIndex < fullText.length) {
                    typingText = fullText.substring(0, typingIndex + 1);
                    typingIndex++;
                    typingTimer = 0;
                    if (typingIndex % 3 === 0) playSound('typing');
                }

                if (workshopTimer > 250) {
                    workshopPhase = 2;
                    workshopTimer = 0;
                    playSound('checkpoint');
                }
            }
            // Phase 2: Transition vers les qu√™tes
            else if (workshopPhase === 2) {
                if (workshopTimer > 100) {
                    currentPhase = 'quest';
                    resetQuest();
                }
            }
        }

        function resetQuest() {
            scrollX = 0;
            heroX = 100;
            questState = 'scroll';
            checkpointsPassed = 0;
            checkpoints.forEach(cp => {
                cp.passed = false;
                cp.glowTimer = 0;
            });
            bossHP = bossMaxHP;
            phaseTimer = 0;
        }

        function updateQuest() {
            phaseTimer++;

            const seq = questSequences[currentQuestIndex];

            if (seq.parallel) {
                updateParallelQuest(seq);
                return;
            }

            switch (questState) {
                case 'scroll':
                    // Avancer
                    scrollX += 2.5;
                    heroX = 150;

                    if (frameCount % 20 === 0) playSound('step');

                    // V√©rifier checkpoints - √©clairage quand on approche
                    checkpoints.forEach((cp, i) => {
                        const totemScreenX = cp.x - scrollX + WIDTH / 2;
                        
                        // D√©clencher le glow uniquement quand le h√©ros est juste devant le totem
                        if (!cp.passed && totemScreenX <= heroX + 10 && totemScreenX >= heroX - 40) {
                            if (cp.glowTimer === 0) {
                                cp.glowTimer = 60; // Dur√©e du glow
                                playSound('totem_glow');
                                addParticles(totemScreenX, GROUND_Y - 80, '#ffd700', 8, 'spark');
                            }
                        }
                        
                        // Marquer comme pass√© quand on d√©passe
                        if (!cp.passed && scrollX > cp.x - 200) {
                            cp.passed = true;
                            checkpointsPassed++;
                            showCheckpointMessage = cp;
                            checkpointMessageTimer = 90;
                            playSound('checkpoint');
                            addParticles(WIDTH / 2, HEIGHT / 2, '#4ade80', 20, 'confetti');
                            addParticles(totemScreenX, GROUND_Y - 100, '#4ade80', 15, 'explosion');
                        }
                        
                        // D√©cr√©menter le timer de glow
                        if (cp.glowTimer > 0) cp.glowTimer--;
                    });

                    if (checkpointMessageTimer > 0) checkpointMessageTimer--;
                    else showCheckpointMessage = null;

                    // Arriv√©e au boss
                    if (scrollX > BOSS_POSITION - 300) {
                        questState = 'boss_intro';
                        phaseTimer = 0;
                        flash = 0.35;
                        shake = 8;
                        playSound('boss_intro');
                        addParticles(WIDTH / 2, HEIGHT / 2, seq.boss.color, 25, 'spark');
                    }
                    break;

                case 'boss_intro':
                    if (phaseTimer > 120) {
                        questState = 'fight';
                        phaseTimer = 0;
                    }
                    break;

                case 'fight':
                    attackTimer++;

                    if (attackTimer > 35 && !heroAttacking) {
                        heroAttacking = true;
                        attackTimer = 0;
                        playSound('attack');
                    }

                    if (heroAttacking && attackTimer > 10 && attackTimer < 15 && !bossHit) {
                        bossHit = true;
                        bossHitTimer = 12;
                        const damage = 18 + Math.floor(Math.random() * 12);
                        bossHP -= damage;
                        playSound('hit');
                        shake = 15;
                        hitStop = 4;
                        addDamageNumber(WIDTH - 180, HEIGHT / 2 - 50, damage);
                        addParticles(WIDTH - 200, HEIGHT / 2 - 20, seq.boss.color, 15, 'explosion');
                        addParticles(WIDTH - 200, HEIGHT / 2 - 20, '#fff', 5, 'spark');
                    }

                    if (attackTimer > 25) {
                        heroAttacking = false;
                        bossHit = false;
                    }

                    if (bossHitTimer > 0) bossHitTimer--;

                    if (bossHP <= 0) {
                        bossHP = 0;
                        questState = 'victory';
                        phaseTimer = 0;
                        playSound('boss_death');
                        shake = 40;
                        flash = 1;
                        addParticles(WIDTH - 200, HEIGHT / 2 - 20, '#ffd700', 50, 'explosion');
                        addParticles(WIDTH - 200, HEIGHT / 2 - 20, '#fff', 20, 'spark');
                    }
                    break;

                case 'victory':
                    if (phaseTimer > 90) {
                        questState = 'castle';
                        phaseTimer = 0;
                        heroX = -50;
                        playSound('victory');
                    }
                    break;

                case 'castle':
                    heroX += 3.5;

                    if (heroX > WIDTH / 2 - 60 && phaseTimer < 180) {
                        seq.flagColors.forEach(color => {
                            if (!flags.includes(color)) {
                                flags.push(color);
                                playSound('flag');
                                addParticles(WIDTH / 2, HEIGHT / 2 - 50, color, 20, 'confetti');
                            }
                        });
                    }

                    if (phaseTimer > 180) {
                        currentQuestIndex++;
                        if (currentQuestIndex >= questSequences.length) {
                            currentPhase = 'final';
                            playSound('final');
                            addParticles(WIDTH / 2, HEIGHT / 2 - 40, '#ffd700', 80, 'confetti');
                        } else {
                            resetQuest();
                        }
                    }
                    break;
            }
        }

        // √âtat pour qu√™te parall√®le
        let parallelState = {
            scrollX: 0,
            phase: 'scroll',
            boss1HP: 100,
            boss2HP: 100,
            timer: 0
        };

        function updateParallelQuest(seq) {
            parallelState.timer++;

            switch (parallelState.phase) {
                case 'scroll':
                    parallelState.scrollX += 2.5;

                    if (frameCount % 20 === 0) playSound('step');

                    // Checkpoints avec glow
                    checkpoints.forEach((cp, i) => {
                        const totemScreenX = cp.x - parallelState.scrollX + WIDTH / 2;
                        
                        // D√©clencher le glow uniquement quand les h√©ros sont juste devant
                        if (!cp.passed && totemScreenX <= 190 && totemScreenX >= 130) {
                            if (cp.glowTimer === 0) {
                                cp.glowTimer = 60;
                                playSound('totem_glow');
                                addParticles(totemScreenX, GROUND_Y - 80, '#ffd700', 8, 'spark');
                            }
                        }
                        
                        if (!cp.passed && parallelState.scrollX > cp.x - 200) {
                            cp.passed = true;
                            checkpointsPassed++;
                            showCheckpointMessage = cp;
                            checkpointMessageTimer = 90;
                            playSound('checkpoint');
                            addParticles(WIDTH / 2, HEIGHT / 2, '#4ade80', 20, 'confetti');
                            addParticles(totemScreenX, GROUND_Y - 100, '#4ade80', 15, 'explosion');
                        }
                        
                        if (cp.glowTimer > 0) cp.glowTimer--;
                    });

                    if (checkpointMessageTimer > 0) checkpointMessageTimer--;
                    else showCheckpointMessage = null;

                    if (parallelState.scrollX > BOSS_POSITION - 300) {
                        parallelState.phase = 'boss_intro';
                        parallelState.timer = 0;
                        playSound('boss_intro');
                    }
                    break;

                case 'boss_intro':
                    if (parallelState.timer > 120) {
                        parallelState.phase = 'fight';
                        parallelState.timer = 0;
                        attackTimer = 0;
                    }
                    break;

                case 'fight':
                    attackTimer++;

                    if (attackTimer > 35 && !heroAttacking) {
                        heroAttacking = true;
                        attackTimer = 0;
                        playSound('attack');
                    }

                    if (heroAttacking && attackTimer > 10 && attackTimer < 15 && !bossHit) {
                        bossHit = true;
                        bossHitTimer = 12;
                        const damage1 = 18 + Math.floor(Math.random() * 12);
                        const damage2 = 18 + Math.floor(Math.random() * 12);
                        parallelState.boss1HP -= damage1;
                        parallelState.boss2HP -= damage2;
                        playSound('hit');
                        shake = 15;
                        hitStop = 4;
                        addDamageNumber(WIDTH / 4 + 80, HEIGHT / 2 - 50, damage1);
                        addDamageNumber(3 * WIDTH / 4 + 80, HEIGHT / 2 - 50, damage2);
                        addParticles(WIDTH / 4 + 80, HEIGHT / 2 - 20, seq.bosses[0].color, 12, 'explosion');
                        addParticles(3 * WIDTH / 4 + 80, HEIGHT / 2 - 20, seq.bosses[1].color, 12, 'explosion');
                    }

                    if (attackTimer > 25) {
                        heroAttacking = false;
                        bossHit = false;
                    }

                    if (bossHitTimer > 0) bossHitTimer--;

                    if (parallelState.boss1HP <= 0 && parallelState.boss2HP <= 0) {
                        parallelState.boss1HP = 0;
                        parallelState.boss2HP = 0;
                        parallelState.phase = 'victory';
                        parallelState.timer = 0;
                        playSound('boss_death');
                        shake = 40;
                        flash = 1;
                        addParticles(WIDTH / 4 + 80, HEIGHT / 2 - 20, '#ffd700', 40, 'explosion');
                        addParticles(3 * WIDTH / 4 + 80, HEIGHT / 2 - 20, '#ffd700', 40, 'explosion');
                    }
                    break;

                case 'victory':
                    if (parallelState.timer > 90) {
                        parallelState.phase = 'castle';
                        parallelState.timer = 0;
                        heroX = -50;
                        playSound('victory');
                    }
                    break;

                case 'castle':
                    heroX += 3.5;

                    if (heroX > WIDTH / 2 - 80 && parallelState.timer < 180) {
                        seq.flagColors.forEach(color => {
                            if (!flags.includes(color)) {
                                flags.push(color);
                                playSound('flag');
                                addParticles(WIDTH / 2, HEIGHT / 2 - 50, color, 20, 'confetti');
                            }
                        });
                    }

                    if (parallelState.timer > 180) {
                        currentQuestIndex++;
                        currentPhase = 'final';
                        playSound('final');
                    }
                    break;
            }
        }

        // === RENDU ===

        function render() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);

            // Shake
            ctx.save();
            if (shake > 0) {
                const dx = (Math.random() - 0.5) * shake;
                const dy = (Math.random() - 0.5) * shake;
                ctx.translate(dx, dy);
                shake *= 0.9;
                if (shake < 0.5) shake = 0;
            }

            switch (currentPhase) {
                case 'workshop':
                    renderWorkshop();
                    break;
                case 'quest':
                    renderQuest();
                    break;
                case 'final':
                    drawFinalScreen();
                    break;
            }

            drawParticles();
            drawDamageNumbers();

            // Flash
            if (flash > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${flash})`;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                flash *= 0.85;
                if (flash < 0.05) flash = 0;
            }

            ctx.restore();
        }

        function renderWorkshop() {
            drawWorkshopBackground();

            // Personnages autour de la table
            const positions = [
                { x: WIDTH / 2 - 150, y: HEIGHT / 2 + 20 },
                { x: WIDTH / 2 - 80, y: HEIGHT / 2 + 80 },
                { x: WIDTH / 2 + 80, y: HEIGHT / 2 + 80 },
                { x: WIDTH / 2 + 150, y: HEIGHT / 2 + 20 },
                { x: WIDTH / 2, y: HEIGHT / 2 + 100 }
            ];

            allTeams.forEach((team, i) => {
                const pos = positions[i];
                const bobY = Math.sin(frameCount * 0.05 + i) * 3;
                drawHero(pos.x, pos.y + bobY, team, frameCount, false, 0.9);

                // Nom
                ctx.fillStyle = team.color;
                ctx.font = '9px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(team.shortName, pos.x, pos.y + 35);
                ctx.textAlign = 'left';
            });

            // Bulle de dialogue
            if (workshopPhase >= 1 && typingText) {
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(WIDTH / 2 - 180, HEIGHT - 90, 360, 40);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(WIDTH / 2 - 180, HEIGHT - 90, 360, 40);

                ctx.fillStyle = '#fff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(typingText + (frameCount % 30 < 15 ? '|' : ''), WIDTH / 2, HEIGHT - 65);
                ctx.textAlign = 'left';
            }

            // Message de phase
            if (workshopPhase === 2) {
                drawMessage('Ateliers termines', 'Les equipes partent en quete...', '#4ade80');
            }

            // Titre
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(10, 10, 220, 35);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText('ATELIERS METIER', 20, 33);
        }

        function renderQuest() {
            const seq = questSequences[currentQuestIndex];

            if (seq.parallel) {
                renderParallelQuest(seq);
                return;
            }

            const teams = seq.teams;

            switch (questState) {
                case 'scroll':
                    drawScrollBackground(scrollX);

                    // Totems
                    checkpoints.forEach(cp => {
                        const totemX = cp.x - scrollX + WIDTH / 2;
                        if (totemX > -100 && totemX < WIDTH + 100) {
                            drawTotem(totemX, GROUND_Y, cp, cp.passed);
                        }
                    });

                    // H√©ros
                    teams.forEach((team, i) => {
                        drawHero(heroX - i * 35, GROUND_Y - 25 + i * 10, team, frameCount, false, 1);
                    });

                    // Message checkpoint
                    if (showCheckpointMessage) {
                        drawCheckpointMessage(showCheckpointMessage.label, showCheckpointMessage.icon);
                    }

                    // HUD
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(10, 10, 250, 50);
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 12px Courier New';
                    ctx.fillText(`Quete: ${teams.map(t => t.shortName).join(' + ')}`, 20, 30);
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px Courier New';
                    ctx.fillText(`Objectif: Vaincre ${seq.boss.name}`, 20, 48);
                    break;

                case 'boss_intro':
                    drawBattleBackground();

                    teams.forEach((team, i) => {
                        drawHero(180 - i * 35, GROUND_Y - 25 + i * 10, team, frameCount, false, 1);
                    });

                    drawBoss(WIDTH - 180, HEIGHT / 2 - 30, seq.boss, frameCount);

                    drawMessage(`${seq.boss.icon} ${seq.boss.name} arrive !`, seq.boss.subtitle, '#ff4444');
                    break;

                case 'fight':
                    drawBattleBackground();

                    teams.forEach((team, i) => {
                        drawHero(200 - i * 35, GROUND_Y - 25 + i * 10, team, frameCount, heroAttacking, 1);
                    });

                    drawBoss(WIDTH - 180, HEIGHT / 2 - 30, seq.boss, frameCount, bossHitTimer > 0);
                    drawBossHP(seq.boss, bossHP, bossMaxHP);
                    break;

                case 'victory':
                    drawBattleBackground();

                    teams.forEach((team, i) => {
                        drawHero(200 - i * 35, GROUND_Y - 25 + i * 10, team, frameCount, false, 1);
                    });

                    drawMessage('VICTOIRE !', `${seq.boss.name} est vaincu !`, '#4ade80');
                    break;

                case 'castle':
                    drawCastleBackground();
                    drawCastle(WIDTH / 2, HEIGHT / 2 - 20, 1, flags);

                    if (heroX < WIDTH / 2 - 40) {
                        teams.forEach((team, i) => {
                            drawHero(heroX - i * 30, GROUND_Y - 25 + i * 10, team, frameCount, false, 1);
                        });
                    }
                    break;
            }

            drawCastleHUD();
            drawProgressBar();
        }

        function renderParallelQuest(seq) {
            const team1 = seq.teams[0];
            const team2 = seq.teams[1];
            const boss1 = seq.bosses[0];
            const boss2 = seq.bosses[1];

            switch (parallelState.phase) {
                case 'scroll':
                    drawScrollBackground(parallelState.scrollX);

                    // Totems
                    checkpoints.forEach(cp => {
                        const totemX = cp.x - parallelState.scrollX + WIDTH / 2;
                        if (totemX > -100 && totemX < WIDTH + 100) {
                            drawTotem(totemX, GROUND_Y, cp, cp.passed);
                        }
                    });

                    // Deux h√©ros
                    drawHero(130, GROUND_Y - 40, team1, frameCount, false, 1);
                    drawHero(180, GROUND_Y - 10, team2, frameCount, false, 1);

                    if (showCheckpointMessage) {
                        drawCheckpointMessage(showCheckpointMessage.label, showCheckpointMessage.icon);
                    }

                    // HUD
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.fillRect(10, 10, 280, 50);
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 12px Courier New';
                    ctx.fillText(`Double quete: ${team1.shortName} + ${team2.shortName}`, 20, 30);
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px Courier New';
                    ctx.fillText(`Boss: ${boss1.name} & ${boss2.name}`, 20, 48);
                    break;

                case 'boss_intro':
                    drawBattleBackground();

                    // S√©parateur
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(WIDTH / 2, 100);
                    ctx.lineTo(WIDTH / 2, HEIGHT - 50);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    drawHero(WIDTH / 4 - 50, GROUND_Y - 25, team1, frameCount);
                    drawBoss(WIDTH / 4 + 80, HEIGHT / 2 - 30, boss1, frameCount);

                    drawHero(3 * WIDTH / 4 - 50, GROUND_Y - 25, team2, frameCount);
                    drawBoss(3 * WIDTH / 4 + 80, HEIGHT / 2 - 30, boss2, frameCount);

                    drawMessage('DOUBLE DEPLOIEMENT', '', '#ff4444');
                    break;

                case 'fight':
                    drawBattleBackground();

                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(WIDTH / 2, 100);
                    ctx.lineTo(WIDTH / 2, HEIGHT - 50);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    drawHero(WIDTH / 4 - 50, GROUND_Y - 25, team1, frameCount, heroAttacking);
                    drawBoss(WIDTH / 4 + 80, HEIGHT / 2 - 30, boss1, frameCount, bossHitTimer > 0 && parallelState.boss1HP > 0);

                    drawHero(3 * WIDTH / 4 - 50, GROUND_Y - 25, team2, frameCount, heroAttacking);
                    drawBoss(3 * WIDTH / 4 + 80, HEIGHT / 2 - 30, boss2, frameCount, bossHitTimer > 0 && parallelState.boss2HP > 0);

                    // Barres de vie
                    // Boss 1
                    ctx.fillStyle = 'rgba(0,0,0,0.85)';
                    ctx.fillRect(WIDTH / 4 - 80, 50, 160, 45);
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(WIDTH / 4 - 80, 50, 160, 45);
                    ctx.fillStyle = '#ff4444';
                    ctx.font = 'bold 11px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${boss1.icon} ${boss1.name}`, WIDTH / 4, 68);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(WIDTH / 4 - 70, 75, 140, 12);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(WIDTH / 4 - 70, 75, Math.max(0, parallelState.boss1HP / bossMaxHP) * 140, 12);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(WIDTH / 4 - 70, 75, 140, 12);

                    // Boss 2
                    ctx.fillStyle = 'rgba(0,0,0,0.85)';
                    ctx.fillRect(3 * WIDTH / 4 - 80, 50, 160, 45);
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(3 * WIDTH / 4 - 80, 50, 160, 45);
                    ctx.fillStyle = '#ff4444';
                    ctx.fillText(`${boss2.icon} ${boss2.name}`, 3 * WIDTH / 4, 68);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(3 * WIDTH / 4 - 70, 75, 140, 12);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(3 * WIDTH / 4 - 70, 75, Math.max(0, parallelState.boss2HP / bossMaxHP) * 140, 12);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(3 * WIDTH / 4 - 70, 75, 140, 12);

                    ctx.textAlign = 'left';
                    break;

                case 'victory':
                    drawBattleBackground();
                    
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(WIDTH / 2, 100);
                    ctx.lineTo(WIDTH / 2, HEIGHT - 50);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    drawHero(WIDTH / 4 - 50, GROUND_Y - 25, team1, frameCount);
                    drawHero(3 * WIDTH / 4 - 50, GROUND_Y - 25, team2, frameCount);
                    drawMessage('DOUBLE VICTOIRE !', 'Les deux boss sont vaincus !', '#4ade80');
                    break;

                case 'castle':
                    drawCastleBackground();
                    drawCastle(WIDTH / 2, HEIGHT / 2 - 20, 1, flags);

                    if (heroX < WIDTH / 2 - 60) {
                        drawHero(heroX, GROUND_Y - 35, team1, frameCount);
                        drawHero(heroX - 40, GROUND_Y - 5, team2, frameCount);
                    }
                    break;
            }

            drawCastleHUD();
            drawProgressBar();
        }

        // Boucle principale
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // D√©marrage
        startScreen.addEventListener('click', () => {
            initAudio();
            startScreen.classList.add('hidden');
            gameState = 'playing';
        });

        gameLoop();
    </script>
</body>

</html>
